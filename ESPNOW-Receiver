//DOIT ESP32 DEVKIT V1 is the board I used
#include <esp_now.h>
#include <WiFi.h>
#include <Adafruit_PWMServoDriver.h>
#include <Wire.h>
//PCA9685

String hostname = "Catcher";
int OKLED = 27;
bool isConnected = false;
unsigned long lastReceiveTime = 0;
unsigned long previousMillis = 0; 
unsigned long interval = random(2000, 5000); // generates a random number between 2000 and 5000
const unsigned long TIMEOUT_PERIOD = 5000; // Adjust the timeout period in milliseconds
float xSmoothed;
float ySmoothed;
float xPrev;
float yPrev;
int joyX; 
int joyY;
int mapX;
int mapY;
const int numSamples = 10;
bool mod1 = false;
bool mod2 = false;
bool mod3 = false;
bool mod4 = false;
// Servo name to number
int lLidTop = 0;
int lLidBot = 1;
int lEyeLeft = 2;
int lEyeRight = 3;
int lEyeUp = 4;
int lEyeDown = 5;
int rLidTop = 6;
int rLidBot = 7;
int rEyeLeft = 8;
int rEyeRight = 9;
int rEyeUp = 10;
int rEyeDown = 11;
int wingMid = 12;
int wingLeft = 13;
int wingRight = 14;
int neck = 15;


// Structure example to receive data
// Must match the sender structure

typedef struct struct_message {

  int xpos;
  int ypos;
  bool mod1;
  bool mod2;
  bool mod3;
  bool mod4;

} struct_message;

// Create a struct_message called myData

struct_message myData;

// callback function that will be executed when data is received

void OnDataRecv(const uint8_t * mac, const uint8_t *incomingData, int len) {
  // Update lastReceiveTime
      lastReceiveTime = millis();

  memcpy(&myData, incomingData, sizeof(myData));


    Serial.print("Bytes received: ");
    Serial.println(len);
  
    Serial.print("xpos: ");
    Serial.println(myData.xpos);
    Serial.print("ypos: ");
    Serial.println(myData.ypos);
   /* Serial.print("mod1: ");
    Serial.println(myData.mod1);
    Serial.print("mod2: ");
    Serial.println(myData.mod2);
    Serial.print("mod3: ");
    Serial.println(myData.mod3);
    Serial.print("mod4: ");
    Serial.println(myData.mod4);
    Serial.println();
    */
}

// called this way, it uses the default address 0x40
Adafruit_PWMServoDriver pwm = Adafruit_PWMServoDriver();

/*******************SERVOS
0 - lLidTop MG996R Servo
1 - lLidBot MG996R Servo
2 - lEyeLeft MG996R Servo
3 - lEyeRight MG996R Servo
4 - lEyeUp MG996R Servo
5 - lEyeDown MG996R Servo
6 - rLidTop MG996R Servo
7 - rLidBot MG996R Servo
8 - rEyeLeft MG996R Servo
9 - rEyeRight MG996R Servo
10 - rEyeUp MG996R Servo
11 - rEyeDown MG996R Servo
12 - wingMid MG996R Servo
13 - wingLeft #DS3240 Servo
14 - wingRight #DS3240 Servo
15 - neck #DS3240 Servo
*/

// this accounts for both types of servo but doesn't seem to work with Arduino code?
//#define SERVOMIN  600 // this is the 'minimum' pulse length count (out of 4096)
//#define SERVOMAX  2500 // this is the 'maximum' pulse length count (out of 4096)

#define SERVOMIN  125 // this is the 'minimum' pulse length count (out of 4096)
#define SERVOMAX  590 // this is the 'maximum' pulse length count (out of 4096)


void setup() {
//Sanity Delay
delay(500);

randomSeed(analogRead(0)); // Initialize random number generator

// Set hostname (not actually required)

  WiFi.setHostname(hostname.c_str()); //define hostname

// Set device as a Wi-Fi Station

  WiFi.mode(WIFI_STA);



//initialise servos
  pwm.begin();
  pwm.setPWMFreq(60);  // Analog servos run at ~60 Hz updates

Serial.begin(115200);

// Set servos to neutral
Serial.println("Homing Servos");
  //set all servos to default neutral 90
  Serial.println("Homing Servos");
  for (int i = 4; i <16; i++){
    pwm.setPWM(i,0,angleToPulse(90)); // all the way forward
  }

    pwm.setPWM(lLidTop,0,angleToPulse(0)); // all the way forward
    pwm.setPWM(lLidBot,0,angleToPulse(0)); // all the way foward

    
delay(1000);
          
//set pin modes
  pinMode(OKLED,OUTPUT);

//init led
  digitalWrite(OKLED,LOW);


/*
//////////////////TASK PRIORITY

Causes crash 

xTaskCreate(
   EYES,     // function name
  "EYES",  // task name
  1000,           // stack size
  NULL,           // task parameters
  1,              // priority (lower number = higher priority)
  NULL            // task handle
);
*/


// Init ESP-NOW

  if (esp_now_init() != ESP_OK) {

    Serial.println("Error initializing ESP-NOW");
    return;

  }



 
// Once ESPNow is successfully Init, we will register for recv CB to

// get recv packer info

  esp_now_register_recv_cb(OnDataRecv);

}
void loop() {
  // If no packet has been received for TIMEOUT_PERIOD
  if (millis() - lastReceiveTime > TIMEOUT_PERIOD) {
    // Turn on OKLED
    digitalWrite(OKLED, HIGH);
    isConnected = false;
  } else {
    // Turn off OKLED
    digitalWrite(OKLED, LOW);
    isConnected = true;
  }

  // Check if the interval has passed
  unsigned long currentMillis = millis();
  if (currentMillis - previousMillis >= interval) {
    // Save the current time
    previousMillis = currentMillis;

    // Call the Blink function
    Blink();

    // Generate a new random interval
    interval = random(2000, 5000);
  }

  Eyes();

}


int angleToPulse(int ang){
   int pulse = map(ang,0, 180, SERVOMIN,SERVOMAX);// map angle of 0 to 180 to Servo min and Servo max 
  // Serial.print("Angle: ");Serial.print(ang);
//   Serial.print(" pulse: ");Serial.println(pulse);
   return pulse;
}

void Eyes(){

// joystick postion to average and smooth
   joyX = myData.xpos;
   joyY = myData.ypos;

 // Check if joystick values are within the dead zone
  if (joyX > 1835 && joyX < 1940) {
    mapX = 90;
  } else {
    // manually mapping joystick range to angle
    mapX = map(joyX,0,4095,0,180);
  }

  if (joyY > 1825 && joyY < 1895) {
    mapY = 90;
  } else {
    mapY = map(joyY,0,4095,0,180);
  }

// if too slow, mess with these rations (need to = 1 in total)
   xSmoothed = (mapX *0.3) + (xPrev * 0.7);
   ySmoothed = (mapY *0.3) + (yPrev * 0.7);

   xPrev = xSmoothed;
   yPrev = ySmoothed;

//Need to mirror these

// Left Eye Movement
  pwm.setPWM(lEyeLeft,0,angleToPulse(xSmoothed)); // Left
  pwm.setPWM(lEyeRight,0,angleToPulse(180 - xSmoothed)); // Right
  pwm.setPWM(lEyeUp,0,angleToPulse(ySmoothed)); // Up Down
  pwm.setPWM(lEyeDown,0,angleToPulse(180 - ySmoothed)); // Down

//Right Eye Movement  
  pwm.setPWM(rEyeLeft,0,angleToPulse(xSmoothed)); // Left
  pwm.setPWM(rEyeRight,0,angleToPulse(180 - xSmoothed)); // Right
  pwm.setPWM(rEyeUp,0,angleToPulse(ySmoothed)); // Up Down
  pwm.setPWM(rEyeDown,0,angleToPulse(180 - ySmoothed)); // Down

}

void Blink(){
    pwm.setPWM(lLidTop,0,angleToPulse(0)); // all the way forward Eyes Closed
    pwm.setPWM(lLidBot,0,angleToPulse(0)); // all the way foward
    delay(300);
    // prob less than 90 required
    pwm.setPWM(lLidTop,0,angleToPulse(50)); //Eyes Open
    pwm.setPWM(lLidBot,0,angleToPulse(50)); 

}
